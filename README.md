<div align=center>
	<img src="https://capsule-render.vercel.app/api?type=waving&color=auto&height=200&section=header&text=C%20%EA%B0%9C%EB%B0%9C%20%EB%A7%88%EC%8A%A4%ED%84%B0%ED%81%B4%EB%9E%98%EC%8A%A4&fontSize=90" />	
</div>


사람들이 코딩을 배우는데 실패하는 99%의 이유는 튜토리얼의 지옥에 빠져 있기 때문입니다. 

<b>"함께 무언가를 만들지 않는 튜토리얼은 반드시 피하십시오."</b>

[저자에게 책 내용 중 궁금한 부분을 물어보기](https://cafe.naver.com/ArticleList.nhn?search.clubid=31031000&search.menuid=5&search.boardtype=L)
<br/><br/>


### C 개발 마스터클래스 1권과 2권의 소스 코드입니다. (레포지토리 #1)

+ [레포지토리 #1 <-- APAS 시스템을 제외한 모든 소스 코드 (here)](https://github.com/sweetPro-Tutorial/C-Masterclass)
  
+ [레포지토리 #2 <-- APAS 시스템용 소스 코드](https://github.com/sweetPro-Tutorial/APAS)

+ [교보문고로 가기](https://search.kyobobook.co.kr/search?keyword=C%20%EA%B0%9C%EB%B0%9C%20%EB%A7%88%EC%8A%A4%ED%84%B0&gbCode=TOT&target=total)


---

<div align=center>
	<img src="https://github.com/sweetPro-Tutorial/sweetPro-Tutorial/blob/main/book_description-754.jpg" />	
</div>

---

### 1권 목차 

```
머리말	22

저자 소개	22
C 언어가 당신에게 줄 수 있는 것	25
누구를 위한 책인가?	28
이 책은 이렇게 합니다	30
두 권으로 구성	31
샘플 코드와 6가지 프로젝트	31
'호기심 많은 사람을 위하여' 와 '도전과제'	32
인쇄 규칙	33
여러분께 기대합니다	33


1.  개발환경을 만듭시다.	35

1.1. 여기서 살펴볼 내용	36

1.2. Windows용 개발환경 만들기	37
step1 - gcc 컴파일러 설치	37
step2 - 컴파일러용 초기 환경 설정	39
step3 - Visual Studio Code 에디터 설치	43
step4 - C 개발용 Visual Studio Code 확장팩 설치	49
step5 - Visual Studio Code용 초기 환경 설정	53
step6. 생애 첫 C 프로그램 만들기	60
bash 터미널에 대해 좀 더 자세히 알아봅시다.	64

1.3. Windows에서 실행 시 한글 깨짐 해결 방법	68

1.4 Mac용 개발환경 만들기	72
step1. gcc 컴파일러 설치	72
step2. Visual Studio Code 에디터 설치	75
step3. C 개발용 Visual Studio Code 확장팩 설치	79
step4. 생애 첫 C 프로그램 만들기	83
step5. Visual Studio Code 용 초기 환경 설정	88

1.5. Linux용 개발환경 만들기	91
step1. gcc 컴파일러 설치	91
step2. Visual Studio Code 에디터 설치	95
step3. C 개발용 Visual Studio Code 확장팩 설치	102
step4. 생애 첫 C 프로그램 만들기	106
step5. Visual Studio Code 용 초기 환경 설정	112


2.  가장 기본적인 기능을 훑어봅시다.	116

2.1. 여기서 살펴볼 내용	117

2.2. 프로그램의 시작점 main	119
main 함수	120
printf 함수	122

2.3. 변수와 상수의 차이	128
변수	128
상수	133

2.4. 숫자의 데이터 타입	136
주석으로 설명문을 달아 봅시다.	136
정수 타입 4가지	139
실수 타입 3가지	149
정수 타입에 필요한 메모리의 상대적인 관계	153

2.5. 수상한 실수값?	155
실수값은 근사값	155
원천적인 오차	156
리눅스 환경일 경우, 컴파일 에러 발생 시 (collect2: error)	162

2.6. 불리언, 문자, 문자열 데이터 타입	166
boolean 타입	166
char 타입	168
문자열 타입	170
사용된 코드들	180
호기심 많은 사람을 위하여	181

2.7. 계산하기	189
사칙연산	190
계산 결과를 출력하는 printf	191
C 언어의 나누기	194
실수의 나눗셈 /	195
정수의 나눗셈 : 몫과 나머지, / 와 %	196
사용된 코드들	198
도전해 봅시다	199
Challenge 1.	199
Challenge 2.	200
해결방법 예시	200

2.8. 변수는 데이터 임시 저장소	203
퀴즈	203
변수 만들기	205
변수의 명명규칙	206
금화 계산기 program	208
사용자와 소통하는 변수	211
사용자로부터 입력받는 scanf	212
사용된 코드들	215
도전해 봅시다	216
Challenge 1.	216
해결방법 예시	216

2.9. 선택의 순간 if	219
알고리즘(algorithm)	219
조건문 if	221
온갖 마법이 일어나는 곳, 블록 { }	223
C 언어의 비교 연산자 < > == != <= >=	224
아침에 일찍 일어나기 프로그램	226

2.10. 논리를 표현합시다	232
논리 연산자 &&, ||, !	232
논리적 AND	232
논리적 NOT	234
논리적 OR	235
Refactoring(리팩토링), 코드의 구조조정	236
사용된 코드들	240
도전해 봅시다	241
Challenge 1.	241
Challenge 2.	241
Challenge 3.	242
해결방법 예시	242

2.11. 워밍업 프로젝트 : 홀짝 Game	246
요구 분석	246
기능① 임의의 숫자를 생성하는 rand	248
C 함수의 메뉴얼	250
매뉴얼 보는 방법	253
첫 번째 주의사항	255
두 번째 주의사항	256
기능② 플레이어의 예측을 입력받는 scanf	258
기능③ 누가 승리했는지 판단하기	259
사용된 코드들	262
호기심 많은 사람을 위하여	263

2.12. 반복은 강합니다, 루프!	266
반복문 while	266
반복문 for	271
for 와 while 선택하기	274
무한반복	274
사용된 코드들	277
도전해 봅시다	278
Challenge 1.	278
해결방법 예시	279

2.13. 홀짝 Game 개선하기	282
예 : 홀짝 게임 반복하기	282
읽기 좋게 리팩토링	286
사용된 코드들	290
호기심 많은 사람을 위하여	291
섹션을 마치며	297


3.  App#1 - Up & Down Game으로 배우는 프로그램을 개발하는 초간단 절차	299

3.1. 여기서 살펴볼 내용	300

3.2. 프로그램의 구성요소를 데이터 관점에서 살펴보기	301
데이터와 알고리즘	302
UP & Down Game의 룰	304
데이터 분석 절차	304
step① 데이터 후보 골라내기	305
step② 후보 데이터 검증하기	306
step③ 데이터 타입 결정하기	308

3.3. 알고리즘 관점에서 살펴보기	309
무엇을 봐야 하나요?	309
알고리즘 분석 절차	309
step① 알고리즘 후보 골라내기	310
step② 후보 정리하기	311
step③ 후보 검증하기	312
step④ 처리 순서 작성	313

3.4. 알고리즘에 대한 Q & A	315
첫 번째 질문 : 프로그램 개발에 알고리즘이 중요한가?	315
두 번째 질문 : 문제 해결 절차만 작성하면 모두 알고리즘인가?	316
세 번째 질문 : 좋은 알고리즘을 고르는 방법이 있는가?	318
마지막 질문	319

3.5. C 언어로 바꿔 쓰기	321
데이터를 C 언어로 번역하기	321
step① 한글명을 영어로 변환하기	321
step② 소스 코드 내에 삽입하기	322
step③ 초기값 주기	323
알고리즘을 C 언어로 바꿔 쓰기	324
step① 처리 순서를 소스 코드 내에 삽입하기	324
step② 기능을 C 언어로 변환하기	325
작성 후 검토, code review	330
사용된 코드들	333
호기심 많은 사람을 위하여	334
도전해 봅시다	341
Challenge 1.	341
Challenge 2.	342
Challenge 3.	343
해결방법 예시	343
섹션을 마치며	352


4.  계산을 더 잘 다뤄봅시다	354

4.1. 여기서 살펴볼 내용	355

4.2. 사칙연산을 더 잘 다뤄봅시다 part1	356
계산식을 C 로 바꾸기	357
아주 크거나 작은 수를 C 로 표현하기	360
만유인력 계산 프로그램	361
아주 크거나 작은 수 출력하기	366
연산자 사이의 우선순위 + - * / %	367

4.3.사칙연산을 더 잘 다뤄봅시다 part2	368
증가 연산자 ++, 감소 연산자 --	368
증감연산자 사용 시 주의사항	369
가능한 피해야 할 줄여쓰기	372
사용된 코드들	374

4.4. 비교연산을 더 잘 다뤄봅시다	375
참이란 무엇일까요? 0, 1	376
비교연산자 사이의 우선순위	378
"조건식이 참이면"의 여러가지 표현	380

4.5. 논리연산을 더 잘 다뤄봅시다	382
비교연산자와 함께 쓰이면?	382
드 모르간의 법칙(De Morgan’s Laws)	383
if 를 잘 사용하기 위한 핵심 기법. 간략화	386
논리식 간략화	386
단순하게 만들기	390
간략화가 잘 안되면 Divide and Conquer 합니다	391
피연산자의 순서에 대하여	393
사용된 코드들	394

4.6. bit 로 연산하기	395
컴퓨터의 원초적 빌딩블록 bit	396
디지트와 수의 체계	397
C 언어의 16진수	401
비트 AND	403
용도 1 : 특정 비트를 0 으로 만들 때 사용	404
용도 2 : 특정 비트 값을 알아내기 위해 사용	405
비트 OR	406
용도 : 특정 비트 값을 1 로 만들 때 사용	407
XOR	408
용도 1 : 특정 비트를 반전시키는데 사용	409
용도 2 : 암호화 및 복호화에 사용	410
왼쪽 시프트, 오른쪽 시프트  <<, >>	411
왼쪽 시프트의 용도: * 2의 배수	412
오른쪽 시프트의 용도: ÷ 2의 배수	413
1의 보수 (one's complement)	414
용도 : 어떤 값에 대한 1의 보수값을 구할 때 사용	414
사용된 코드들	417
호기심 많은 사람을 위하여	418
도전해 봅시다	426
Challenge 1.	426
Challenge 2.	427
해결방법 예시	431
섹션을 마치며	433


5.  개발자가 만들어 쓰는 함수	434

5.1. 여기서 살펴볼 내용	435

5.2. 세상에 존재하는 함수	437
C 언어의 표준 함수를 찾는 방법#1 - 레퍼런스 북	437
C 언어의 표준 함수를 찾는 방법#2 - 인터넷 사이트	440

5.3. 함수를 만들어 봅시다	444
함수를 만드는 이유	444
함수를 만드는 방법	446
함수 선언 : 사용하기 전에 선언해야 합니다	447
함수 정의 : 함수의 본체를 작성해야 합니다.	451
새 함수 printResult 를 사용해 봅시다	454
하나 더 해 봅시다	455
사용된 코드들	459
호기심 많은 사람을 위하여	460
도전해 봅시다	463
Challenge 1.	463
해결방법 예시	464
섹션을 마치며	466


6.  변수와 상수를 더 잘 다뤄봅시다	467

6.1. 여기서 살펴볼 내용	468

6.2. 상자의 용도를 결정하는 type	469
C 언어가 제공하는 기본타입 3 가지	470
정수 타입을 자세히 들여다봅시다	470
음수 값이 필요 없을 때 unsigned	472
unsigned 사용시 주의사항	473
실수 타입을 자세히 들여다봅시다	475
실수 타입: double, float	475
복소수 타입: double complex, float complex	482
void 타입	484
사용된 코드들	485

6.3. 상수를 더 잘 다뤄봅시다	487
상수를 사용하는 3 가지 방법	488
리터럴 상수 Literal Constant	489
심볼릭 상수 Symbolic Constant	491
변수상수 Variable Constant	492
사용된 코드들	494

6.4. 변수의 영역다툼 Scope	495
보여야 쓸 수 있습니다	496
아예 블럭 밖에 선언하면? 전역 변수!	499
편한 길과 바른 길	500
사용된 코드들	503
6.5. 깐깐한 타입을 유연하게 만드는 Casting	504
타입은 변환할 수 있습니다	504
타입 변환의 예외	507
사용된 코드들	508
호기심 많은 사람을 위하여	509
도전해 봅시다	513
Challenge 1.	513
해결방법 예시	514
섹션을 마치며	516


7.  주소 타입을 다뤄봅시다 Pointer	517

7.1. 여기서 살펴볼 내용	518

7.2. 주소 보고 찾아왔어요	519
주소를 보고 찾아 갑니다	520
변수의 주소를 알려주는 주소연산자 &	522
주소 타입의 변수를 선언해주는 *	523
포인터 변수가 가리키는 곳을 찾아주는 값 연산자 *	525
포인터 변수 선언문의 의미	527
* 기호에 대하여	528
조금은 특별한 void 포인터 타입	529

7.3. 포인터 타입이 필요한 이유	533
저장된 값을 바꾸는 두가지 방법	533
함수에 전달한 입력값은 '복사본' 입니다	534
주소를 함수에 전달하는 이유	537
swap 함수 만들기	540

7.4. 포인터 연산을 다뤄 봅시다	547
포인터 연산	547
포인터의 덧셈	548
포인터의 뺄셈	550
사용된 코드들	553
호기심 많은 사람을 위하여	554
도전해 봅시다	559
Challenge 1.	559
Challenge 2.	559
Challenge 3.	560
Challenge 4.	560
Challenge 5.	561
해결방법 예시	563
섹션을 마치며	569


8.  흐름 제어를 더 잘 다뤄봅시다	570

8.1. 여기서 살펴볼 내용	571

8.2. 조건을 더 잘 다뤄봅시다	572
switch 문을 다뤄 봅시다	573
switch-case 문 사용법	575
switch-case 문의 처리 흐름	578
swith 문의 다중 선택	580
간단한 조건을 다루는 조건 연산자 ? :	583
조건 연산자를 사용하기 위한 조건	585
사용된 코드들	587

8.3. 반복을 더 잘 다뤄봅시다	588
반복의 기본	589
반복문을 강제 종료하는 break	589
반복문을 계속하는 continue	591
continue 는 제거 합시다	594
반복문: do while 문	594
goto 로 만드는 반복	596

8.4. 재귀로 만드는 반복 recursion	599
재귀의 의미 recursion	599
반복형태로 개발한 경우	602
재귀형태로 개발한 경우	603
사용된 코드들	606
호기심 많은 사람을 위하여	607
도전해 봅시다	610
Challenge 1.	610
Challenge 2.	611
해결방법 예시	612
섹션을 마치며	615


9.  데이터 구조의 핵심. 배열	616

9.1. 여기서 살펴볼 내용	617

9.2. 배열의 기본적인 사용법	619
배열이란?	619
배열과 인덱스	621
배열의 구성요소는 인덱스를 사용해서 구분합니다 index	622
배열을 초기화하는 방법들	624

9.3. 배열 이름을 사용하는 방법	629
배열 이름은 무엇일까요?	629
배열 이름은 누가 어디에 사용할까요?	632
배열 이름으로 연산해 봅시다	633
배열 이름을 함수의 '입력값'으로 사용하기	637
사용된 코드들	640

9.4. 배열 사용 예1: 문자 배열과 문자열을 사용합시다	642
용사의 상태창 예	643
문자 배열과 문자열을 사용합시다	645
문자열 한 줄을 읽고 싶을 땐 fgets	652
사용된 코드들	656

9.5. 잠깐! 터미널에서 한글을 입력 받을 경우	657
첫 번째 주의사항	657
두 번째 주의사항	658
사용된 코드들	666

9.6. 배열 사용 예2: 배열의 값을 정렬해 봅시다	667
일상의 정렬 알고리즘	667
알고리즘을 C언어로 번역하기: 루프 속의 루프	670
눈여겨 볼 점	676
사용된 코드들	678

9.7. 배열의 값을 정렬하는 더 편리한 방법	679
C 언어의 정렬용 표준 함수 qsort	679
qsort 용 비교 함수 작성 규약	680
사용된 코드들	686

9.8. 차원을 여행해 봅시다. 1차원에서 2차원으로	688
배열도 차원이 있습니다	688
2차원 배열	691
2차원 배열에서 구성요소를 지정하는 방법	697
9.9. 2차원 배열을 함수에 전달하는 방법	700
2차원 배열 검색하기	700
2차원 배열을 함수에 전달 해 봅시다	703
2차원 배열은 메모리를 얼마나 차지할까요?	708
3차원 이상의 배열은 사용하면 안됩니다	709
사용된 코드들	711
호기심 많은 사람을 위하여	712
도전해 봅시다	715
Challenge 1.	715
Challenge 2.	716
Challenge 3.	718
Challenge 4.	720
해결방법 예시	722
섹션을 마치며	729


10.  변수와 상수에 질서를!	730

10.1. 여기서 살펴볼 내용	731

10.2. 관련된 변수를 묶어 주는 struct	733
구조와 구조체 타입 structure, struct type	733
구조체 타입 예시: 가로등 정보 관리	734
case1. 배열을 사용해서 가로등 정보를 개발할 경우	736
case2. 구조체 타입을 사용해서 가로등 정보를 개발할 경우	737
구조체 타입을 사용해서 변수 만들기	738
변수의 구성요소를 사용하는 방법	739

10.3 .도우미 함수를 사용해 봅시다	745
도우미 함수 만들기	745
구조체의 크기	749

10.4. 긴 타입 이름 대신 별명을 사용하는 typedef	752
구조체 타입을 간략하게 만드는 typedef	752
구조체 포인터 변수를 간략하게 표현합시다	754

10.5. 관련된 심볼릭 상수를 묶어 주는 enum	757
심볼릭 상수를 묶어주는 enum	757
열거 타입으로 변수 만들기	759
식별자를 초기화 하기	760
변수 선언이 불필요한 경우를 위한 무명 열거 타입	761

10.6. 같은 메모리를 구성요소끼리 공유하는 union	767
같은 메모리를 구성요소끼리 공유하는 union	767
유니온 타입의 사이즈	769
리틀 엔디안, 빅 엔디안	772
사용된 코드들	776
호기심 많은 사람을 위하여	777
도전해 봅시다	784
Challenge 1.	784
Challenge 2.	784
Challenge 3.	785
Challenge 4.	786
해결방법 예시	787
섹션을 마치며	792


11.  App#2 - HerosQuest game. 배운 내용을 익혀봅시다	793

11.1. 여기서 살펴볼 내용	794

11.2. 개발해야 할 '기능'들을 찾아내는 또 다른 방법	796
필요한 기능을 어떻게 찾아낼 것인가?	796
'사용 사례' 기법	797
사용 사례 Use Case	798
사용 사례 다이어그램 UseCase Diagram	800
사용 사례 정의서 Use Case specification	802
요약 정리	803

11.3. 필요한 기능 목록 찾아내기	806
게임 실행 화면	806
Hero's Quest 프로그램의 '사용 사례'	808
사용 사례로부터 "기능 목록"을 도출해 봅시다	811
사후검토1: 빠뜨린 기능은 없는지 검토하기	812
사후검토2: 기능 구조도 검토 및 확정 하기	814

11.4. step1. 빈 함수로 기능을 개발하는 Top-Down	818
기능을 개발하기	818
최상위 기능은 main 함수가 됩니다	819
하위 기능이 있으면 호출합시다	820
Top-Down 식 해결책: 빈 함수로 만들기 dummy module	822

11.5. step2. 빈 함수를 실제 함수로 만들기-intro, makeDungeon	826
1. intro 함수를 실제 함수로 만들기	826
2. makeDungeon 함수를 실제 함수로 만들기	830

11.6. step3. 빈 함수를 실제 함수로 만들기-playHero, printDungeon	837
printDungeon 함수를 실제 함수로 만들기	837
playHero 함수를 실제 함수로 만들기	841

11.7. step4. 빈 함수를 실제 함수로 만들기-moveHero	847
playHero 알고리즘 작성하기	847
playHero 알고리즘을 빈함수로 바꿔 쓰기	848
빈 함수 inputCommand 를 실제 함수로 만들기	853
빈 함수 moveHero 를 실제 함수로 만들기	854
사용된 코드들 - version1	868

11.8. 개발 후 검토와 개선 아이디어	870
개발자의 친절1. 플레이 점수 계산	870
개발자의 친절2. 승패 메시지를 풍성하게	871
개발자의 친절3. 현재 상태를 플레이어에게 알려주기	873
개선 아이디어1-이동명령 추가	876
개선 아이디어2-성능 개선	878
개선 아이디어3-자동 생성 map	880
개선 아이디어4-몬스터 추가	881
개선 아이디어5-이동명령 텔레포트 추가	883
사용된 코드들 - version2	885
사용된 코드들 - version3	887
호기심 많은 사람을 위하여	890
섹션을 마치며	897


12.  문자와 문자열을 더 잘 다뤄봅시다	899

12.1. 여기서 살펴볼 내용	900

12.2. 보이는 문자와 보이지 않는 문자	901
문자란?	901
입력한 문자를 아스키 코드로 보여주는 프로그램	903
아스키 ASCII 문자	906
C언어의 내장 문자들	909
사용된 코드들	911

12.3. 문자열 처리 함수들	912
문자열이란?	913
문자열 처리 함수들	917
1) 복사용 함수 : strcpy, strncpy	919
2) 연결용 함수 : strcat, strncat, sprintf	921
3) 비교용 함수 : strcmp, strncmp	925
4) 탐색용 함수	927
4.1) 문자열 내에서 특정 문자열 찾을 때 strstr	929
NULL 사용 시 주의사항	931
4.2) 문자열에서 특정 문자를 찾을 때 strchr	933
4.3) 문자 집합과 불일치하는 첫 글자를 찾는 strspn	935
4.4) 문자집합과 일치하는 첫 문자를 찾을 때 strcspn	938
4.5) 문자집합으로 문자열을 잘라 낼 때 strtok	939
문자열 길이 계산용 함수를 만들어 봅시다	948
사용된 코드들	953

12.4. 문자열 넘침 방지	955
왜 문자 배열의 크기가 중요할까?	955
문자열을 처리할 때 오버플로우가 발생하지 않게 하려면?	956
그런데, 문자열 오버플로우가 발생하면 어떻게 조치해야 하나?	960
사용된 코드들	970
호기심 많은 사람을 위하여	972
도전해 봅시다	977
Challenge 1.	977
해결방법 예시	977
섹션을 마치며	981


2권에 대하여	983

참고자료	986

색인	988

```

---

### 2권 목차

```
머리말	19

저자 소개	19
C 언어가 당신에게 줄 수 있는 것	22
누구를 위한 책인가?	25
이 책은 이렇게 합니다	27
두 권으로 구성	28
샘플 코드와 6가지 프로젝트	28
'호기심 많은 사람을 위하여' 와 '도전과제'	29
인쇄 규칙	30
여러분께 기대합니다	30


13.  데이터를 영구적으로 보관하는 파일 file	32

13.1. 여기서 살펴볼 내용	33

13.2. 화면에 출력하듯 파일에 출력하는 fprintf	34
파일과 파일 포인터	34
화면에 출력하는 printf, 파일에 출력하는 fprintf	37
파일을 여는 fopen	39
파일을 닫는 fclose	42
파일에 데이터를 출력하는 fprintf	43
예외처리 로직	44
파일을 사용할 때 공통적으로 삽입되는 코드	47
사용된 코드들	49

13.3. 키보드로 입력받듯 파일로부터 입력 받는 fscanf	50
친절한 scanf 함수	50
까칠한 fscanf	52
많은 데이터를 읽으려면?	57
사용된 코드들	60

13.4. 텍스트 파일을 더 잘 다뤄 봅시다-쓰기 fprintf, fputs, fwrite	61
파일의 mode 를 더 잘 다뤄 봅시다	61
골라 쓰는 다양한 파일 출력용 함수	64
printLampInfo 함수를 파일용으로 바꿔봅시다	65
3가지 함수 fprintf, fputs, fwrite 비교	77
사용된 코드들	79

13.5. 텍스트 파일을 더 잘 다뤄 봅시다-읽기 fscanf, fgets, fread	80
파일로부터 데이터를 읽는 다양한 함수들	80
fscanf, fgets, fread 비교	90
사용된 코드들	93

13.6. 파일의 내용을 수정해 봅시다	94
파일 내의 현재 위치란?	95
파일 위치를 원하는 곳으로 지정해 봅시다	100
파일의 현재 위치를 이동시키는 fseek	102
파일의 현재 위치를 알려주는 ftell	108
사용된 코드들	110

13.7. 피해야 할 습관, 하드코딩!	111
data.txt 외에 다른 파일을 보고 싶다면?	111
case1. 하드 코딩 방식의 해법	113
case2. 하드 코딩 방식보다 더 좋은 방식은?	114
사용된 코드들	122

13.8. 바이너리 파일을 다뤄 봅시다	123
바이너리 파일이란?	123
step1. 바이너리 mode 로 파일 열기	127
step2. 바이너리 모드로 파일 읽기	129
헥사로 데이터 출력하기 Hexdump	131
fread 함수로 바이너리 모드로 읽기	135
step3. 바이너리 모드로 쓰기	137
사용된 코드들	138
호기심 많은 사람을 위하여	139
도전해 봅시다	142
Challenge 1.	142
Challenge 2.	143
해결방법 예시	143
섹션을 마치며	148


14.  App3-LanguageTranslator. 언어 번역기를 만들어 봅시다	150

14.1. 여기서 살펴볼 내용	151

14.2. 역사적 배경과 필요한 기능 목록	153
프로그램의 개요	153
모스 부호란?	155
모스 부호의 국제표준	157
morse 프로그램의 사용 사례(usecase)	159

14.3. 기능 개발하기-main 과 checkOption	164
최상위 기능 "morse utility" 개발하기	164
하위 기능1-checkOption 함수 개발	169
하위 기능2-anomalyReport 함수 개발	173

14.4. 기능 개발하기-toMorse (데이터 구조와 알고리즘)	176
toMorse 인코더를 개발해 봅시다	176
필요한 데이터	177
필요한 알고리즘1 - 입력파일 검사	181
필요한 알고리즘2 - 영문 텍스트를 모스 코드로 변환하기	187
모스 부호의 "공백"에 관한 규칙	197

14.5. 기능 개발하기-toMorse (예외와 에러 처리)	202
에러 처리	202
알고리즘 보강하기: 단어 식별 알고리즘	204
이 알고리즘을 그림으로 표현하기: 상태도 State Diagram	206
필요한 데이터	208
필요한 알고리즘	209
예외 처리	216

14.6. 기능 개발하기-toText	219
모스 부호 디코더 개발	219
필요한 데이터	221
필요한 알고리즘1. 모스 부호를 영문 텍스트로 변환하기	223
알고리즘을 C 언어로 번역하기	229
필요한 알고리즘2. 모스 부호를 영문 텍스트로 변환하기	240

14.7. 개발 후 검토와 개선 아이디어	242
1. 테스트 및 디버깅용 코드 제거	242
2. 코드 구조 조정	245
개선 아이디어1-Korean to Morse code translator	246
개선 아이디어2-출력 매체 변경	248
개선 아이디어3-모스 부호 변환 서비스 프로그램	249
사용된 코드들	251
호기심 많은 사람을 위하여	252
도전해 봅시다	259
Challenge 1.	259
해결방법 예시	263
섹션을 마치며	266


15.  긴 코드는 분할해서 관리합시다	268

15.1. 여기서 살펴볼 내용	269

15.2. 파일 분할에 필요한 3가지 배경지식	270
배경 지식	270
배경지식1. C 파일의 컴파일과 링크의 작동 방식	271
배경지식2. include 매크로의 작동 방식	274
배경지식3. 모듈화 원리 Modularization	278

15.3. 프로그램 소스 코드의 분할 anomaly.c, .h	286
코드 분할 준비	286
이상 보고서 기능 분리하기	290
중요: 헤더 파일 작성 시 주의사항	296
분할 컴파일 방법	298

15.4. 프로그램 소스 코드의 분할 encode.c, .h	306
복습: 프로그램 소스 코드를 분할하는 방법	306
인코딩 기능 분리하기	307
분리 중에 만나는 컴파일 에러와 extern	315

15.5. 프로그램 소스 코드의 분할 decode.c, .h	317
디코딩 기능 분리하기	317
step1: decode.c 작성	318
step2: decode.h 작성	321
step3: main.c 분할 컴파일 대응	324
선택사항: main.h 작성	325
헤더 파일 작성 시 주의 사항	327

15.6. 개발 후 검토와 개선 아이디어	329
1. anomaly.c 에서 전역변수 제거	329
2. 외부 변수 사용을 허용하는 extern 제거	332
개선 아이디어	336
사용된 코드들	338
도전해 봅시다	339
Challenge 1.	339
해결방법 예시	340
섹션을 마치며	342


16.  프로그램과 생명주기를 함께하는 static	344

16.1. 여기서 살펴볼 내용	345

16.2. static 데이터를 다뤄 봅시다	346
static 사용법 #1. 전역변수(global variable)를 외부 소스 파일로부터 차단하기	346
static 사용법 #2. 지역변수(local variable)의 값을 보존하기	351
static 사용 시의 에러 핸들링	354
사용된 코드들	361
호기심 많은 사람을 위하여	362
섹션을 마치며	365


17.  중요한 메모리	366

17.1. 여기서 살펴볼 내용	367

17.2. 프로그램이 사용하는 메모리 구조	368
프로세스와 메모리	368
프로세스의 메모리 구조	372

17.3. 예시: 프로세스가 메모리에 적재되는 과정	378
1단계: 프로세스가 실행되기 직전	378
2단계 : main 함수 호출 시	379
3단계 : main 에서 함수 function1 호출 시	380
4단계 : function1 함수가 종료되어 main 함수로 반환 시	381
프로세스가 사용할 수 있는 메모리 크기	382
스택 영역과 힙 영역의 크기	384

17.4. 동적 메모리를 사용해 봅시다	387
메모리를 할당하는 두 가지 방식	387
메모리 식별자 즉, 이름	390
요약정리: 동적 메모리 사용 절차	393

17.5. 동적 메모리 할당 관련 함수들	397
1. 메모리 할당용 함수 malloc	397
2. 깨끗한 메모리 할당용 함수 calloc	403
3. 메모리 재할당용 함수 realloc	404
4. 할당된 메모리를 해제하는 함수 free	406

17.6. 메모리 다룰 때 알아 두면 유용한 기타 함수들	409
1. 메모리를 원하는 값으로 채워주는 memset	409
메모리 내용을 복사하는 memcpy	411
기타 : 사용을 권하지 않은 함수	413
동적 메모리와 정적 메모리! 둘 중 무엇을 써야 할까?	417
사용된 코드들	419

17.7. 실습1: Singly Linked List 를 만들어 봅시다 part1	420
링크드 리스트 개념	420
링크드 리스트 종류	423
싱글 링크드 리스트	425
싱글 링크드 리스트에 필요한 데이터 구조	427
Node 타입과 LinkedList 타입의 사용 예시	430

17.8. 실습1: Singly Linked List 를 만들어 봅시다 part2	444
step1. 리스트 정보 만들기	444
step2. pushFront : 리스트 맨 앞에 노드를 추가하는 기능	445
step3. makeNode : 노드 생성용 함수	449
step4. printList : 리스트 내의 모든 노드를 보여주는 함수	452
step5. printNode : 노드를 보여주는 함수	454
step6. popFront : 리스트 맨 앞 노드를 삭제하는 함수	457
step7. isEmpty : 리스트가 비어 있는지 확인하는 함수	460
step8. freeNode : 노드에 할당된 메모리 제거하는 함수	460
step9. eraseAllList : 리스트 내의 모든 노드를 삭제하는 함수	462

17.9. Singly Linked List 코드 재사용을 위한 파일 분할	465
list.h 헤더 파일 분리	465
list.c 소스 파일 분리	467
분리한 파일 사용하기	468
사용된 코드들	470

17.10. 실습2: Doubly Linked List 를 만들어 봅시다	471
더블 링크드 리스트	472
1. 기존 타입 수정	475
2. 도우미 함수 수정/개발	476
사용된 코드들	494
호기심 많은 사람을 위하여	496
도전해 봅시다	506
Challenge 1.	506
Challenge 2.	507
Challenge 3.	509
해결방법 예시	510
섹션을 마치며	524


18.  디버깅	526

18.1. 여기서 살펴볼 내용	527

18.2. 프로그램을 디버그 해 봅시다	528
사전지식	529
환경설정1. 디버깅을 위한 빌드 설정: settings.json	531
환경설정2. 디버거 설정: launch.json	532
프로그램을 디버깅해 봅시다	538
초 간단 디버거 사용법	540

18.3. 디버거를 더 잘 사용해 봅시다	546
Breakpoint 사용법	546
중단점을 더 잘 사용해 봅시다 Conditional Breakpoint	547
디버깅 중에 소스 코드를 수정했다면?	550
강제 종료되는 프로그램의 디버깅	551

18.4. 실행하지 않고 버그를 찾아주는 lint	560
lint 배경 지식	560
CppCheck 설치 방법	563
lint 가 잘 작동하는지 확인해 봅시다	573

18.5. 자주 만나는 코딩 실수들	576
1. 경계값 오류	576
2. 입력값 누락 오류	578
3. 짝이 맞지 않는 오류	582
4. 명령문을 끝맺지 않은 오류	588
사용된 코드들	590
호기심 많은 사람을 위하여	591
섹션을 마치며	592


19.  App4-WordCounter. 워드카운터를 만들어 봅시다	594

19.1. 여기서 살펴볼 내용	595

19.2. 버전1-워드 카운터 개발	598
진화적 프로토타입 모델 Evolutionary Prototype Model	598
Phase 1. 요구분석	599
Phase 2. 프로토타입 설계	602
Phase 3. 프로토타입 개발	607
프로그램 테스트	614

19.3. 버전2-워드 분석기 개발(고도화1차)	620
Phase 4. 고객평가와 Feedback	620
Phase 2. 빠른 설계	622
Phase 3. 빠른 개발	628

19.4. 버전2.1-치명적인 버그 발견과 버그 픽스 part1	639
Phase 4. 고객평가와 Feedback	639
Phase 2. 빠른 설계	642
Phase 3. 버그 픽스 개발	643
더 많은 테스트 케이스	649

19.5. 버전2.1-치명적인 버그 발견과 버그 픽스 part2	654
Phase 3. 정렬 기능 개발	654
step1. 빈도수 순으로 정렬	655
step2. 같은 빈도수끼리는 알파벳 순으로 정렬	658

19.6. 버전3-블랙리스트 추가(고도화2차)	666
Phase 4. 고객평가와 Feedback	666
phase 2. 빠른 설계	667
Phase 3. 빠른 개발	669

19.7. 개발 후 검토와 개선 아이디어	679
개발후 검토-중복된 코드 제거	679
개선 아이디어-URL 을 사용해서 텍스트 파일 받기	680
개선 아이디어-통계 기능 추가	684
사용된 코드들	687
호기심 많은 사람을 위하여	688
섹션을 마치며	692


20.  App5- APAS. 대기오염정보분석시스템(Air Pollution information Analysis System) 개발	693

20.1. 여기서 살펴볼 내용	694

20.2. APAS 가 무엇인지 알아봅시다	697
APAS 란?	697
프로그램 구성	700
정보연계 프로토콜	703
20.3. 발급받은 인증키를 테스트해 봅시다	708
발급받은 API 인증키 테스트	708
주의사항	712
정보연계 프로토콜 문서 - 개발자용	714

20.4. program1 - 수집모듈 - 정보연계	716
APAS 프로젝트 폴더 구조	716
정보연계 기능 개발	722
정보연계용 명령어 라인 만들기	723
C 코드 - 명령어 라인을 실행	725
프로그램의 인트로	729
수집모듈을 별도 C 파일로 분리	730

20.5. program1 - 주기적인 실행	733
주기적으로 실행하는 방법	733
현재 시각 표시	738

20.6. program1 - 공용 C 파일 다루기	741
프로그램들 간에 소스 파일 공유 방법	741
컴파일 옵션 설정 - 분산된 소스 파일용	745
공통 코드 분리, 한 번 더!	749

20.7. program1 - 설정 파일 다루기(ini 파서) part1	757
환경설정 파일 - apas.ini	757
ini 파서	759
알고리즘	760
데이터 구조	761
알고리즘 구현 #1 - 파일 순회 - ini_parser.c	763
중간 검토 - 코드의 구성 - common.h	765
알고리즘 구현 #2 - 라인의 종류 파악	766
다양한 테스트 케이스 사용과 에러 처리	768

20.8. program1 - 설정 파일 다루기(ini 파서) part2	769
오탐 에러 제거	769
알고리즘 구현 #3 - 일치하는 키 값을 저장	774
20.9. program1 - ini 파서 개선과 함수 포인터	790

핵심 포인트 - '기능'을 입력값으로!	790
기능을 입력값으로 전달하는 함수 포인터 function pointer	791
step1: keyHandler 함수 분리하기	796
step2: keyHandler 함수를 iniParse 함수에 입력값으로 전달하기	798

20.10. program1 - 수집모듈 - 데이터 추출(json 파서) part1	803
json 포맷	804
json 파서	807

20.11. program1 - 수집모듈 - 데이터 추출(json 파서) part2	815
알고리즘 구현 #1 - 파일 순회	815
collector 소스 파일	817
알고리즘 구현 #2 - 유효한 객체인지 확인	825
알고리즘 구현 #3 - 원하는 대기오염정보를 리스트에 저장	831

20.12. program1 - 수집모듈 - 원장(마스터 파일) 저장	837
마스터 파일 포맷	837
알고리즘	838

20.13. program1 - 분석모듈 - 통계 작성	847
통계 파일 포맷	847
분석용 최상위 기능 - analyzer 함수	849
알고리즘 #1 - analyzer	850
알고리즘 #2 - makeStatistics	851

20.14. program1 - 분석모듈 - 알람 작성	866
알람 파일 포맷	866
알고리즘 - makeAlarmFile	868
사용된 코드들	874

20.15. program2 - 운영모듈 - 메인 메뉴	876
메인 C 파일	877
알고리즘 #1 - 메인 메뉴	877

20.16. program2 - 운영모듈 - Menu1. 대기오염 현황 조회	885
알고리즘 #2 - 대기오염 현황 조회 (시도/일/시간별)	885
알고리즘 구현	886

20.17. program2 - 운영모듈 - Menu2. 알람 현황 조회	896
알고리즘 #3 - 알람 현황 조회 (시도별)	896
알고리즘 구현	900

20.18. program2 - 운영모듈 - Menu3. 통계 조회	904
알고리즘 #4 - 대기오염 통계 조회 (시도별/일별)	904
알고리즘 구현	905
사용된 코드들	909
호기심 많은 사람을 위하여	912
섹션을 마치며	913


21.  App6- myChatBot(마이 챗봇). ChatGPT와 연계해서 나만의 챗봇 만들기	915

21.1. 여기서 살펴볼 내용	916

21.2. 인증키를 발급받읍시다	918
ChatGPT의 API 인증키	918
인증키 발급 절차	919
발급된 API 인증키를 테스트해 봅시다.	922

21.3. 마이 챗봇 SW의 구성	926
고려사항	927
main 함수 만들기	928
한글 입력시 문제 해결방법	931
마이 챗봇용 환경변수 설정하기	932
정보연계	935
윈도우 환경에서 외부 명령어 실행 시 문제해결	940
정보추출	946
ChatGPT의 답변을 보여주기	956
'한글'로 질문해 봅시다	958
에러 메시지 처리	963

21.4. 개발 후 검토와 개선 아이디어	967
개선 아이디어#1	967
개선 아이디어#2	975
개선 아이디어#3	978
사용된 코드들	985
섹션을 마치며	988


22.  코딩의 경계를 넘어서 ...... (See Beyond)	990

22.1. 여기서 살펴볼 내용	991

22.2. 프로그래밍의 심리학	992
기억의 한계	992
원칙1 - 가능한 기억해야 할 것을 적게 만들기	996
원칙2 - 함수 내에서 가능한 빨리 빠져나가자! 머리속이 복잡해지기 전에!	998
원칙3 - 중첩된 블록의 깊이는 1 을 유지하자	999

22.3. 프로그래밍의 미학 part1	1007
왜 미학이 필요한가?	1007
방법1 - 들여쓰기	1008
방법2 - 대/소문자 원칙	1010
이름 붙이는 방법 - Naming	1013

22.4. 프로그래밍의 미학 part2	1018
도구1 - 추상화	1019

22.5. 프로그래밍의 미학 part3	1028
단순화를 잘하려면?	1028
코딩도 결국은 글쓰기	1031

22.6. 프로그래밍의 논리학 part1	1036
워밍업 퀴즈	1037
논리를 간단하게 만드는 방법	1040
간략화가 잘 안되면 Divide and Conquer 합시다	1047

22.7. 프로그래밍의 논리학 part2	1050
논리식 간략화에 도움이 되는 불 대수 Boolean algebra	1050
논리는 정확성을 요구합니다	1051
논리 작성을 잘하고 싶은 사람을 위한 조언	1055
사용된 코드들	1059
호기심 많은 사람을 위하여	1061
섹션을 마치며	1067


참고자료	1069

색인	1071

```


